<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MA Towns Map</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      #map {
        width: 100%;
        height: 100%;
      }
      #townSelect,
      #toggleContainer,
      #stats,
      .legend,
      #refreshContainer {
        position: absolute;
        z-index: 2;
        background: white;
        padding: 5px;
        font-family: sans-serif;
      }
      #townSelect {
        top: 10px;
        left: 10px;
      }
      #toggleContainer {
        top: 50px;
        left: 10px;
      }
      #refreshContainer {
        top: 110px;
        left: 10px;
      }
      #stats {
        top: 170px;
        left: 10px;
        font-size: 14px;
      }
      .legend {
        bottom: 30px;
        left: 10px;
        font-size: 12px;
      }
      .legend div {
        display: flex;
        align-items: center;
        margin-bottom: 2px;
      }
      .legend span {
        width: 12px;
        height: 12px;
        display: inline-block;
        margin-right: 5px;
      }
      #loading {
        display: none;
        font-size: 12px;
        color: blue;
        margin-top: 5px;
      }
    </style>
    <link
      href="https://unpkg.com/maplibre-gl@5.18.0/dist/maplibre-gl.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <select id="townSelect">
      <option value="">Select a town</option>
    </select>

    <div id="toggleContainer">
      <label>
        <input type="radio" name="availability" value="bikes" checked />
        Bikes available </label
      ><br />
      <label>
        <input type="radio" name="availability" value="docks" />
        Docks available
      </label>
    </div>

    <div id="refreshContainer">
      <button id="refreshBtn">Refresh data</button>
      <div id="loading">Loading data...</div>
    </div>

    <div class="legend">
      <div><span style="background: red"></span> 0</div>
      <div><span style="background: yellow"></span> 1</div>
      <div><span style="background: green"></span> >1</div>
    </div>

    <div id="stats">
      <strong>Stations Stats:</strong><br />
      Number of stations: 0<br />
      Bikes available: 0<br />
      E-bikes available: 0<br />
      Docks available: 0
    </div>

    <div id="map"></div>

    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl@5.18.0/dist/maplibre-gl.js"></script>

    <script>
      const map = new maplibregl.Map({
        container: "map",
        style: {
          version: 8,
          sources: {
            osm: {
              type: "raster",
              tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
              tileSize: 256,
              attribution:
                'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            },
          },
          layers: [{ id: "osm", type: "raster", source: "osm" }],
        },
        center: [-71.5, 42.3],
        zoom: 8,
      });

      let stationsData = null;
      let townsData = null;
      let selectedTownId = null;

      const statsDiv = document.getElementById("stats");
      const townSelect = document.getElementById("townSelect");
      const loadingDiv = document.getElementById("loading");

      /* ------------------ DATA LOADING ------------------ */

      async function loadInitialStations() {
        const res = await fetch("data/stations.geojson");
        const data = await res.json();
        setStationsData(data);
      }

      async function fetchStationsFromAPI() {
        loadingDiv.style.display = "block";
        try {
          const url = "/.netlify/functions/get-bikes";
          const query = `
            query GetSystemSupply($input: SupplyInput) {
              supply(input: $input) {
                stations {
                  stationId
                  stationName
                  valetName
                  location { lat lng }
                  bikesAvailable
                  bikeDocksAvailable
                  ebikesAvailable
                  scootersAvailable
                  totalBikesAvailable
                  totalRideablesAvailable
                  isValet
                  isOffline
                  isLightweight
                  siteId
                  lastUpdatedMs
                }
              }
            }
          `;
          const response = await fetch(url, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              operationName: "GetSystemSupply",
              variables: {
                input: { regionCode: "BOS", rideablePageLimit: 1000 },
              },
              query,
            }),
          });
          const result = await response.json();

          const stations = result.data.supply.stations;

          const geojson = {
            type: "FeatureCollection",
            features: stations.map((s) => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [s.location.lng, s.location.lat],
              },
              properties: {
                stationId: s.stationId,
                stationName: s.stationName,
                bikesAvailable: s.bikesAvailable,
                ebikesAvailable: s.ebikesAvailable,
                bikeDocksAvailable: s.bikeDocksAvailable,
              },
            })),
          };

          setStationsData(geojson);
        } catch (err) {
          console.error(err);
          alert("Failed to fetch API data");
        } finally {
          loadingDiv.style.display = "none";
        }
      }

      function setStationsData(data) {
        stationsData = data;

        if (map.getSource("stations")) {
          map.getSource("stations").setData(stationsData);
        } else {
          map.addSource("stations", { type: "geojson", data });
          map.addLayer({
            id: "stations-circle",
            type: "circle",
            source: "stations",
            paint: {
              "circle-radius": 6,
              "circle-color": "green",
              "circle-stroke-color": "#000",
              "circle-stroke-width": 1,
            },
          });

          map.on("click", "stations-circle", (e) => {
            const f = e.features[0];
            const p = f.properties;
            new maplibregl.Popup()
              .setLngLat(f.geometry.coordinates)
              .setHTML(
                `<strong>${p.stationName}</strong><br>
                 Bikes: ${p.bikesAvailable}<br>
                 E-bikes: ${p.ebikesAvailable}<br>
                 Docks: ${p.bikeDocksAvailable}`,
              )
              .addTo(map);
          });

          map.on("mouseenter", "stations-circle", () => {
            map.getCanvas().style.cursor = "pointer";
          });
          map.on("mouseleave", "stations-circle", () => {
            map.getCanvas().style.cursor = "";
          });
        }

        updateStationsColor();
        rebuildTownDropdown();
        updateStats();
      }

      /* ------------------ TOWNS ------------------ */

      fetch("data/towns.geojson")
        .then((res) => res.json())
        .then((data) => {
          townsData = data;
          map.addSource("towns", { type: "geojson", data });
          map.addLayer({
            id: "towns-fill",
            type: "fill",
            source: "towns",
            paint: { "fill-color": "#0080ff", "fill-opacity": 0.3 },
          });
          map.addLayer({
            id: "towns-outline",
            type: "line",
            source: "towns",
            paint: { "line-color": "#000", "line-width": 1 },
          });
          map.addLayer({
            id: "towns-highlight",
            type: "line",
            source: "towns",
            paint: { "line-color": "red", "line-width": 3 },
            filter: ["==", "TOWN_ID", -1],
          });
        });

      function rebuildTownDropdown() {
        if (!townsData || !stationsData) return;

        townSelect.innerHTML = '<option value="">Select a town</option>';

        const townsWithStations = townsData.features.filter((town) =>
          stationsData.features.some((st) =>
            turf.booleanPointInPolygon(st.geometry, town.geometry),
          ),
        );

        townsWithStations.forEach((f) => {
          const option = document.createElement("option");
          option.value = f.properties.TOWN_ID;
          option.textContent = f.properties.TOWN;
          townSelect.appendChild(option);
        });
      }

      function highlightTown(id) {
        selectedTownId = id;
        map.setFilter(
          "towns-highlight",
          id ? ["==", "TOWN_ID", id] : ["==", "TOWN_ID", -1],
        );
      }

      /* ------------------ STYLING & STATS ------------------ */

      document
        .querySelectorAll('input[name="availability"]')
        .forEach((r) => r.addEventListener("change", updateStationsColor));

      function updateStationsColor() {
        if (!map.getLayer("stations-circle")) return;

        const mode = document.querySelector(
          'input[name="availability"]:checked',
        ).value;

        map.setPaintProperty(
          "stations-circle",
          "circle-color",
          mode === "bikes"
            ? [
                "case",
                ["==", ["get", "bikesAvailable"], 0],
                "red",
                ["==", ["get", "bikesAvailable"], 1],
                "yellow",
                "green",
              ]
            : [
                "case",
                ["==", ["get", "bikeDocksAvailable"], 0],
                "red",
                ["==", ["get", "bikeDocksAvailable"], 1],
                "yellow",
                "green",
              ],
        );
      }

      function updateStats() {
        if (!stationsData) return;

        let filtered = stationsData.features;

        if (selectedTownId && townsData) {
          const townFeature = townsData.features.find(
            (f) => f.properties.TOWN_ID == selectedTownId,
          );
          if (townFeature) {
            filtered = stationsData.features.filter((s) =>
              turf.booleanPointInPolygon(s.geometry, townFeature.geometry),
            );
          }
        }

        const num = filtered.length;
        const bikes = filtered.reduce(
          (sum, s) => sum + Number(s.properties.bikesAvailable),
          0,
        );
        const ebikes = filtered.reduce(
          (sum, s) => sum + Number(s.properties.ebikesAvailable),
          0,
        );
        const docks = filtered.reduce(
          (sum, s) => sum + Number(s.properties.bikeDocksAvailable),
          0,
        );

        statsDiv.innerHTML = `<strong>Stations Stats:</strong><br>
          Number of stations: ${num}<br>
          Bikes available: ${bikes}<br>
          E-bikes available: ${ebikes}<br>
          Docks available: ${docks}`;
      }

      townSelect.addEventListener("change", (e) => {
        highlightTown(e.target.value ? parseInt(e.target.value) : null);
        updateStats();
      });

      document
        .getElementById("refreshBtn")
        .addEventListener("click", fetchStationsFromAPI);

      /* ------------------ INITIAL LOAD ------------------ */

      map.on("load", () => {
        loadInitialStations();
      });
    </script>
  </body>
</html>
